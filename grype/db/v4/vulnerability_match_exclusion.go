package v4

import "encoding/json"

// VulnerabilityMatchExclusion represents the minimum data fields necessary to automatically filter certain
// vulnerabilities from match results based on the specified constraints.
type VulnerabilityMatchExclusion struct {
	ID            string                                  `json:"id"`                    // The identifier of the vulnerability or advisory
	Constraints   []VulnerabilityMatchExclusionConstraint `json:"constraints,omitempty"` // The constraints under which the exclusion applies
	Justification string                                  `json:"justification"`         // Justification for the exclusion
}

func (e VulnerabilityMatchExclusion) Usable() bool {
	for _, constraint := range e.Constraints {
		if !constraint.Usable() {
			return false
		}
	}

	return true
}

// VulnerabilityMatchExclusionConstraint describes criteria for which matches should be excluded
type VulnerabilityMatchExclusionConstraint struct {
	Vulnerability VulnerabilityExclusionConstraint `json:"vulnerability,omitempty"` // Vulnerability exclusion criteria
	Package       PackageExclusionConstraint       `json:"package,omitempty"`       // Package exclusion criteria
	ExtraFields   map[string]interface{}           `json:"-"`
}

func (c VulnerabilityMatchExclusionConstraint) Usable() bool {
	return len(c.ExtraFields) == 0 && c.Vulnerability.Usable() && c.Package.Usable()
}

func (c *VulnerabilityMatchExclusionConstraint) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.ExtraFields); err != nil {
		return err
	}

	if v, ok := c.ExtraFields["vulnerability"]; ok {
		if v, ok := v.(VulnerabilityExclusionConstraint); ok {
			c.Vulnerability = v
			delete(c.ExtraFields, "vulnerability")
		}
	}

	if p, ok := c.ExtraFields["package"]; ok {
		if p, ok := p.(PackageExclusionConstraint); ok {
			c.Package = p
			delete(c.ExtraFields, "package")
		}
	}

	return nil
}

// VulnerabilityExclusionConstraint describes criteria for excluding a match based on additional vulnerability components
type VulnerabilityExclusionConstraint struct {
	Namespace   string                 `json:"namespace,omitempty"` // Vulnerability namespace
	FixState    FixState               `json:"fix_state,omitempty"` // Vulnerability fix state
	ExtraFields map[string]interface{} `json:"-"`
}

func (v VulnerabilityExclusionConstraint) Usable() bool {
	return len(v.ExtraFields) == 0
}

func (v *VulnerabilityExclusionConstraint) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &v.ExtraFields); err != nil {
		return err
	}

	if n, ok := v.ExtraFields["namespace"]; ok {
		if n, ok := n.(string); ok {
			v.Namespace = n
			delete(v.ExtraFields, "namespace")
		}
	}

	if f, ok := v.ExtraFields["fix_state"]; ok {
		if f, ok := f.(string); ok {
			v.FixState = FixState(f)
			delete(v.ExtraFields, "fix_state")
		}
	}

	return nil
}

// PackageExclusionConstraint describes criteria for excluding a match based on package components
type PackageExclusionConstraint struct {
	Name        string                 `json:"name,omitempty"`     // Package name
	Language    string                 `json:"language,omitempty"` // The language ecosystem for a package
	Type        string                 `json:"type,omitempty"`     // Package type
	Version     string                 `json:"version,omitempty"`  // Package version
	Location    string                 `json:"location,omitempty"` // Package location
	ExtraFields map[string]interface{} `json:"-"`
}

func (p PackageExclusionConstraint) Usable() bool {
	return len(p.ExtraFields) == 0
}

func (p *PackageExclusionConstraint) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &p.ExtraFields); err != nil {
		return err
	}

	if n, ok := p.ExtraFields["name"]; ok {
		if n, ok := n.(string); ok {
			p.Name = n
			delete(p.ExtraFields, "name")
		}
	}

	if l, ok := p.ExtraFields["language"]; ok {
		if l, ok := l.(string); ok {
			p.Language = l
			delete(p.ExtraFields, "language")
		}
	}

	if t, ok := p.ExtraFields["type"]; ok {
		if t, ok := t.(string); ok {
			p.Type = t
			delete(p.ExtraFields, "type")
		}
	}

	if v, ok := p.ExtraFields["version"]; ok {
		if v, ok := v.(string); ok {
			p.Version = v
			delete(p.ExtraFields, "version")
		}
	}

	if loc, ok := p.ExtraFields["location"]; ok {
		if loc, ok := loc.(string); ok {
			p.Location = loc
			delete(p.ExtraFields, "location")
		}
	}

	return nil
}
